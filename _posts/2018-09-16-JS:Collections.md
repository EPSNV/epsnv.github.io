### Всем привет!

На прошедшей неделе добрался до темы, [JS: Коллекции](https://ru.hexlet.io/courses/js_collections). 
Я ее очень ждал, потому что в прошлой жизни я всегда довольно плотно использовал массивы и руки чесались 
пощупать их в JS. Я был в восторге, сравнивая пройденное с Pascal, я написал другу, с которым мы вместе
начинали программировать в школе: "Дошел до массивов в JS. Да уж, это тебе не паскаль, что хочешь можно исполнять :)
данные разных типов могут лежать в одном массиве, длину массива можно менять на ходу, добавляя элементы, 
если у тебя массив A длиной 3 элемента, можно делать A[10] = 5 и будет работать, и т.д". Одноклассник правда 
не разделил моих восторгов, так как варится в другой среде и все давно забыл :). Открыл для себя много нового в этом курсе
очень понравились такие фишки как rest, spread и деструктивное присваивание. 

Долго просидел над задачей : "Реализуйте метод where, основываясь на следующем интерфейсе: 
Функция может принимать любое количество параметров, каждый из которых может быть либо 
функцией, либо объектом. Для функций должна осуществляться простая фильтрация, для объектов 
нужно проверять соответствие элемента коллекции значениям по тем же ключам, что и в 
переданном объекте."

Сначала я хотел вытягивать из передаваемых объектов ключи и мапить их в общий массив в виде 
функций предикатов. Крутил-вертел, синстаксические ошибки разгребал, в итоге отказался от 
этой идеи и исходя из подсказок к заданию догадался, что лучше сделать один предикат который через every проверит 
массив ключей на соответствие с элементом коллекции. Решение в итоге получилось почти как 
учительское. 

Задачи после курса были не сильно сложными. Мне даже показалось, что так лучше усваивается, 
когда много раз повторяешь какой-то несложный прием, доводя его до автоматизма. Единственная 
задача, которая почему-то загнала меня в ступор, это проверка балланса скобок. Я долго 
прокручивал ее в уме пока решал другие задачи. Хотел откусывать скобки с конца и начала строки,
сравнивая на соответствие, но такой подход никак на покрывал такие случаи "()()". Потом был 
вариант, брать первую открывающую скобку, искать аналогичную закрывающую и от этого места делить
 строку на "То что оказалось внутри скобок" и "то, что осталось за скобками", потом рекурсивно 
 перебирая эти два списка. Такой подход не покрывал случай, "((....).....)". Сто раз прочитал 
 "используйте стэк" и постоянно думал "Да как я вам его сюда пристегну!". Потом случилась "Эврика" 
 и я сразу понял, что не обязательно сразу искать пару к первой открывающейся скобке. Решение стало 
 очевидным и даже стало смешно от того, что я не увидел его сразу.
 
 Удалось поплотнее на этой неделе посидеть с книжкой "Код. Тайный язык информатики". Интересная книга, но 
 без практики такой объем информации не усвоить. Очень много схем и текста вида "первый выход подключаем к третьему входу, 
 в свою очередь, выход от этого элемента к пятому входу следущего" и т.п. В глазах начинает рябить от бесконечной вереницы входов, 
 выходов, подключений, переключений. В целом после прочтения общие представления в голове останутся и прочитать ее несомненно стоит.
 
 Впереди важная тема "Деревья", до встречи после ее завершения, друзья!

